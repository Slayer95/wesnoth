#!/usr/bin/env python3


# encoding: utf-8
#
# wmlxgettext -- generate a blank .pot file for official campaigns translations
#                    (build tool for wesnoth core)
#
#
# By Nobun, october 2015
# Thanks to Elvish Hunter for writing code for coloring text under windows
#
#                              PURPOSE
#
# wmlxgettext is a python3 tool that replace the old (but very good)
# perl script with the same name.
# Replacing perl with python3 will ensure more portability.
#
# wmlxgettext is a tool that is directly used during wesnoth build process
# to generate the pot files for the core campaigns.
#
#                              USAGE
#
# If you want to learn how to use wmlxgettext, read the online End-User
# documentation at:
# http://wmlxgettext-unoff.readthedocs.org/en/latest/enduser/index.html
#
#                   SOURCE CODE DOCUMENTATION
#
# While the source code contains some comments that explain what it does at
# that point, the source code is mainly explained on source documentation at:
# http://wmlxgettext-unoff.readthedocs.org/en/latest/srcdoc/index.html

import argparse
from copy import copy
from datetime import datetime
import os
import signal
import sys
import warnings
import pywmlx
from wesnoth.wmltools3 import CrossRef
from wesnoth.wmlmacro import AST, Macro, CrossRefHelper, ReferenceHelper


def commandline(args):
    parser = argparse.ArgumentParser(
        description='Generate .po from WML/lua file list.',
        usage='''wmlxgettext --domain=DOMAIN -o OUTPUT_FILE
                   [--directory=START_PATH]
                   [--recursive] [--initialdomain=INITIAL_DOMAIN]
                   [--package-version=PACKAGE_VERSION]
                   [--no-sort-by-file] [--no-text-colors] [--fuzzy] [--warnall]
                   FILE1 FILE2 ... FILEN'''
    )
    parser.add_argument(
        '--version',
        action='version',
        version='wmlxgettext 2019.09.03.py3'
    )
    parser.add_argument(
        '-o',
        required=True,
        default=None,
        dest='outfile',
        help= ('Destination file. In some special situations you might want '
               'to write the output to STDOUT instead of writing '
               'an actual file (using "-o -"). On a standard usage, however, '
               'you should avoid to write the output to STDOUT (or you can '
               'face some issues related to text encoding). '
               '[**REQUIRED ARGUMENT**]')
    )
    parser.add_argument(
        '--domain',
        default='wmlxgettext',
        required=True,
        dest='domain',
        help= ('The textdomain (on WML/lua file) wich contains the '
               'strings that will be actually translated. '
               '[**REQUIRED ARGUMENT**]')
    )
    parser.add_argument(
        '--directory',
        default='.',
        dest='start_path',
        help=('Complete path of your "start directory". '
              '(Default: current directory). The (relative) path to '
              'every WML/lua file should start from this directory.')
    )
    parser.add_argument(
        '--initialdomain',
        default='wesnoth',
        dest='initdom',
        help=('Initial domain value on WML/lua file when no textdomain '
              'set in that WML/lua file.\nBy default it is equal to '
              '"wesnoth" and usually you don\'t need to change this value.')
    )
    parser.add_argument(
        '--package-version',
        default='PACKAGE VERSION',
        dest='package_version',
        help=('Version number of your wesnoth add-on. You don\'t actually '
              'require to set this option since you can directly edit the '
              'po file produced by wmlxgettext.')
    )
    parser.add_argument(
        '--no-sort-by-file',
        action='store_false',
        default=True,
        dest='sort_by_file',
        help=("By default the list of input files is sorted so that they "
              "are processed in a deterministic order. Use this flag to "
              "process the files in the order that they're named on the "
              "command line.")
    )
    parser.add_argument(
        '--no-text-colors',
        action='store_false',
        default=True,
        dest='text_col',
        help=("By default warnings are displayed with colored text. You can "
              "disable this feature using this flag.")
    )
    parser.add_argument(
        '--warnall',
        action='store_true',
        default=False,
        dest='warnall',
        help="Show all warnings. By default some warnings are hidden."
    )
    parser.add_argument(
        '--fuzzy',
        action='store_true',
        default=False,
        dest='fuzzy',
        help=("If you specify this flag, all sentences contained on the POT "
              "file created by wmlxgettext will be set as fuzzy.\n"
              "By default sentences are NOT set as fuzzy.")
    )
    parser.add_argument(
        '--recursive',
        action='store_true',
        default=False,
        help=("If this option is used, wmlxgettext will scan recursively the "
              "directory set on the '--directory' parameter and checks "
              "itself every WML/lua file. "
              "If this option is used, EXPLICIT LIST of files will be "
              "ignored.")
    )
    parser.add_argument(
        'filelist',
        help='List of WML/lua files of your UMC (source files).',
        nargs='*'
    )

    '''
    Developer Options - not suitable for standard usage:
    --DMode is a reserved flag used to verify how wmlxgettext is internally
            working. When this flag is used (set to ON), an extra
            file (debug.txt) will be created. debug.txt will contain
            useful informations to check if wmlxgettext is working as expected
            (but make sense only for wmlxgettext developers/contributors)
    '''
    parser.add_argument(
        '--DMode',
        action='store_true',
        dest='debugmode',
        default=False,
        help=argparse.SUPPRESS
    )

    return parser.parse_args(args)



def extractor(files, fileref_root, offset = 0):
    for fileno, fx in enumerate(files):
        if fileno < offset:
            continue

        fname = os.path.normpath(os.path.join(fileref_root, fx))
        is_file = os.path.isfile(fname)
        if is_file:
            infile = None
            try:
                infile = open(fname, 'r', encoding="utf-8")
            except OSError as e:
                errmsg = 'cannot read file: ' + e.args[1]
                pywmlx.wmlerr(e.filename, errmsg, OSError)
            if fname.lower().endswith('.cfg'):
                pywmlx.statemachine.run(filebuf=infile, fileref=fx,
                            fileno=fileno, startstate='wml_idle', waitwml=True)
            if fname.lower().endswith('.lua'):
                pywmlx.statemachine.run(filebuf=infile, fileref=fx,
                            fileno=fileno, startstate='lua_idle', waitwml=False)
            infile.close()



def handle_macro_po_sentences(sentlist, po_sentences, start_path="", fileref_root="", outfile=None, fuzzy=False):
    # In fact, Wesnoth's engine expands macros in the preprocessor step.
    # Therefore, the input below ran through wmlxgettext should output
    #
    # msgid "Hello, world."
    # msgstr ""
    #
    # # define GREET MODE WHOM
    # [{MODE}]
    #     {MODE} = _ "Hello, {WHOM}."
    # [/{MODE}]
    # # enddef
    #
    # {GREET message world}
    #
    # To accomplish that through all macro calls and subcalls, we identify
    # three types of macro calls according to their context.
    # A. Inside translatable strings.
    # B. Inside macro definitions, but not inside a string.
    # C. Every other macro call (top level).
    #
    # The simplest case is that macro type A is called directly by
    # a single macro type C. In that case, we:
    # 1. Identify the parameter index "n" in the definition of macro C,
    #    associated with the call of macro A.
    # 2. Substitute the nth parameter of macro C into the string containing
    #    macro call A.
    #
    # There are several factors that complicate it:
    # 1. There may be one or more macros of type B. We need to track their
    #    parameters as well.
    # 2. There may be more than one macro of type C. Each of them represents
    #    a new string in the output.
    # 3. It's possible the parameters of macro(s) type B and C aren't a 1:1
    #    match.
    # 4. Since Wesnoth 1.13.7, named optional macro parameters are available.
    #    through the directive #arg
    # 5. Macros may be deleted with #undef and later redefined.
    #
    # For example, let
    #
    # # define MOODY_GREET MODE QUALIFIER WHOM
    #   {GREET {MODE} (very {QUALIFIER} {WHOM})}
    # # enddef
    #
    # {MOODY_GREET message good world}
    # {MOODY_GREET message bad world}
    #
    # We know that GREET's relevant parameter is the second, and it's affected by
    # the second and third parameters of MOODY_GREET. Fortunately, MOODY_GREET has
    # a finite universe of possible parameters, so we iterate through all of them,
    # and we get
    #
    # msgid "Hello, very good world."
    # msgstr ""
    #
    # msgid "Hello, very bad world."
    # msgstr ""
    #
    # Note that $substitutions are bad practice for localizable strings,
    # as the translator will only be able to relocate the variable, and not
    # act according to their possible values. Many languages have lots of
    # conditional declensions, which warrant exhausting all combinations.
    # Those *are* provided by macros.
    #
    #
    # Strategy:
    # 1. Identify all strings which require preprocessing, as well as their
    #    reference (file name, line number), and parent macro definition.
    #    These are passed to handle_macro_po_sentences.
    #
    # 2. Use wmltools3.CrossRef to parse macro definitions and callsites.
    #    2.1 Note whether there's an #undef in the same file (i.e whether 
    #        the macro is local or global).
    #    2.2. If any of the macros from (1) is non-local, fall back to (3).
    #    2.3. Otherwise, go to (4).
    #
    # 3. Use wmltools3.CrossRef to parse macro definitions and callsites on the entire addon.
    #    3.1. Note whether the macro contains quote marks or WML (error out if so.)
    #    3.2. Note whether the macro contains conditional directives and which.
    #    3.3. Go to (4).
    # 
    # 4. Deeply identify all macro callsites with expansions that include
    #    strings in (1).
    # 5. Propagate macro parameters.
    # 6. Evaluate the strings in (1).
    #
    ctx_macros = {}
    asts_by_sentence = {}
    ids_by_sentence = {}
    (sentences_by_file, sentences_by_macro) = po_sentences
    for fileref, sentences in sentences_by_file.items():
        for posentence in sentences:
            lone_identifiers, complex_identifiers = {}, {}
            # Fill-in lone_identifiers, complex_identifiers
            ast = AST.parse_sentence_with_ids(posentence.sentence, lone_identifiers, complex_identifiers)
            macro = Macro(*posentence.macro)

            ctx_macros[macro] = True
            asts_by_sentence[posentence.sentence] = ast
            ids_by_sentence[posentence.sentence] = (lone_identifiers, complex_identifiers)

    args_by_macro = {}
    xrefs_by_file = {}
    xrefs_all = None

    def resolve_strings_at(dirpath=None, single_file=None):
        if dirpath is None:
            # 2. Use wmltools3.CrossRef to parse macro definitions and callsites.
            filelist = [os.path.normpath(os.path.join(fileref_root, single_file))]
            xrefs = CrossRef(filelist=filelist)
            xrefs_by_file[filelist[0]] = xrefs_by_file # filelist[0] abs path
        else:
            # 3. Use wmltools3.CrossRef to parse macro definitions and callsites on the entire addon.
            xrefs = CrossRef(dirpath=dirpath)
            xrefs_all = xrefs

        for macro in ctx_macros:
            if single_file and macro.fileref != single_file:
                # Ignore in single-file analysis
                continue

            # print("Tracing %s..." % macro)
            xref = macro.to_abs(fileref_root).get_ref(xrefs)
            if xref is None:
                print("Macro %s not referenced" % macro)
                continue

            is_local = xref.undef is not None
            if not is_local and single_file is not None:
                # 2.1 Note whether there's an #undef in the same file (i.e whether 
                #     the macro is local or global).
                # 2.2. If any of the macros from (1) is non-local, fall back to (3).
                raise Exception("Macro %s is exported" % macro)

            contained_sentences = sentences_by_macro[macro]

            # lone identifiers collection    : list<dict>
            all_params_dicts = [ids_by_sentence[s.sentence][0] for s in contained_sentences]
            # complex identifiers collection : list<dict>
            complex_id_dicts = [ids_by_sentence[s.sentence][1] for s in contained_sentences]

            # maybe_parameters: dict<str, bool>
            maybe_parameters = {k:v for fps in all_params_dicts for k,v in fps.items()}
            # macro names with 0 arguments: list<str>
            not_parameters = [id for id in maybe_parameters if not id in xref.args and not id in xref.optional_args]
            # macro names with 1+ arguments: list<str>
            complex_ids = [id for d in complex_id_dicts for id in d.keys()]

            if len(not_parameters) > 0:
                # TODO: Support it in MacroCallNode.replace()
                for s in sentences_by_macro[macro]:
                    print("Unsupported macro \"%s\" in \"%s\". String will not be translated." % (not_parameters[0], s.sentence))

            if len(complex_ids) > 0:
                # 3.1. Note whether the macro contains quote marks or WML (error out if so.)
                # 3.2. Note whether the macro contains conditional directives and which.
                # TODO: Support it in MacroCallNode.replace()
                for s in sentences_by_macro[macro]:
                    print("Unsupported macro \"%s\" in \"%s\". String will not be translated." % (complex_ids[0], s.sentence))

            args_variants = ReferenceHelper.get_arguments(xref, xrefs, maybe_parameters)
            if len(args_variants) == 0:
                for s in sentences_by_macro[macro]:
                    print("No args found for \"%s\". String will not be translated." % s.sentence)
            else:
                # 4. Deeply identify all macro callsites with expansions that include
                #    strings in (1).
                # 5. Propagate macro parameters.
                ReferenceHelper.deep_replace_arguments(args_variants, xrefs)

            args_by_macro[macro] = args_variants

    try:
        for fileref in sentences_by_file:
            resolve_strings_at(dirpath=None, single_file=fileref)
    except Exception as ex:
        print("Fallback to full-tree analysis")
        resolve_strings_at(dirpath=[start_path])

    # 2.3. Otherwise, go to (4).
    # 3.3. Go to (4).
    new_sentences = {}
    for macro, sentences in sentences_by_macro.items():
        args_variants = args_by_macro[macro]
        file_path_abs = os.path.normpath(os.path.join(fileref_root, macro[1]))
        xrefs = xrefs_by_file[file_path_abs] if file_path_abs in xrefs_by_file else xrefs_all
        for po_sentence in sentences:
            sentence_ast = asts_by_sentence[po_sentence.sentence]
            # 6. Evaluate the strings in (1).
            # sub_sentences: list<(str, Macro|NoneType)>
            sub_sentences = AST.evaluate_many_on_one(sentence_ast, args_variants, xrefs)
            for sub_sentence, ctx in sub_sentences:
                # assert(isinstance(ctx, Macro|NoneType))
                po_sentence_variant = copy(po_sentence)
                po_sentence_variant.finfos = copy(po_sentence_variant.finfos)
                po_sentence_variant.sentence = sub_sentence
                if '\x01' + po_sentence_variant.sentence in sentlist:
                    # print("Ignored ref to raw sentence %s" % po_sentence_variant.sentence)
                    # Output has already been written. TODO: FIXME?
                    # sentlist['\x01' + po_sentence_variant.sentence].update_with_commented_string(po_sentence_variant)
                    pass
                elif po_sentence_variant.sentence in new_sentences:
                    # print("New ref in processed sentence %s" % po_sentence_variant.sentence)
                    new_sentences[po_sentence_variant.sentence].update_with_commented_string(po_sentence_variant)
                else:
                    # print("New sentence %s" % po_sentence_variant.sentence)
                    new_sentences[po_sentence_variant.sentence] = po_sentence_variant

    for posentence in new_sentences.values():
        posentence.write(outfile, fuzzy)
        print('', file=outfile)


def main():
    signal.signal(signal.SIGINT, sigint_handler)
    args = commandline(sys.argv[1:])
    pywmlx.ansi_setEnabled(args.text_col)
    pywmlx.wincol_setEnabled(args.text_col)
    pywmlx.set_warnall(args.warnall)
    startPath = os.path.realpath(os.path.normpath(args.start_path))
    fileref_root = startPath
    sentlist = dict()
    fdebug = None
    if args.outfile == '-':
        args.outfile = None
    if args.debugmode:
        fdebug = open('debug.txt', 'w', encoding='utf-8')
    pywmlx.statemachine.setup(sentlist, args.initdom, args.domain,
                              args.warnall, fdebug)
    if args.recursive is False and args.filelist is None:
        pywmlx.wmlerr("bad command line", "FILELIST must not be empty. "
               "Please, run wmlxgettext again and, this time, add some file "
               "in FILELIST or use the --recursive option.")
    elif args.recursive is False and len(args.filelist) <= 0:
        pywmlx.wmlerr("bad command line", "FILELIST must not be empty. "
               "Please, run wmlxgettext again and, this time, add some file "
               "in FILELIST or use the --recursive option.")
    elif args.recursive is False:
        filelist = args.filelist
    # the following elif case implicitly expects that args.recursive is True
    elif args.filelist is not None:
        if len(args.filelist) > 0:
            pywmlx.wmlwarn("command line warning", "Option --recursive was "
                "used, but FILELIST is not empty. All extra file listed in "
                "FILELIST will be ignored.")
        # If we use the --recursive option we recursively scan the add-on
        # directory.
        #    But we want that the file reference informations placed
        # in the .po file will remember the (relative) root name of the
        # addon.
        #    This is why the autof.autoscan function returns a tuple of
        # values:
        #   the first one is the parent directory of the original startPath
        #   the second one is the filelist (with the "fixed" file references)
        fileref_root, filelist = pywmlx.autof.autoscan(startPath)
    # this last case is equal to:
    # if args.recursive is True and args.filelist is None:
    else:
        fileref_root, filelist = pywmlx.autof.autoscan(startPath)
    if args.sort_by_file:
        filelist.sort()
 
    extractor(filelist, fileref_root)

    outfile = None
    if args.outfile is None:
        outfile = sys.stdout
    else:
        outfile_name = os.path.realpath(os.path.normpath(args.outfile))
        try:
            outfile = open(outfile_name, 'w', encoding="utf-8")
        except OSError as e:
            errmsg = 'cannot write file: ' + e.args[1]
            pywmlx.wmlerr(e.filename, errmsg, OSError)
    pkgversion = args.package_version + '\\n"'
    print('msgid ""\nmsgstr ""', file=outfile)
    print('"Project-Id-Version:', pkgversion, file=outfile)
    print('"Report-Msgid-Bugs-To: https://bugs.wesnoth.org/\\n"', file=outfile)
    now = datetime.utcnow()
    cdate = '{:04d}-{:02d}-{:02d} {:02d}:{:02d} UTC\\n"'.format(now.year,
                                                                now.month,
                                                                now.day,
                                                                now.hour,
                                                                now.minute)

    print('"POT-Creation-Date:', cdate, file=outfile)
    print('"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\\n"', file=outfile)
    print('"Last-Translator: FULL NAME <EMAIL@ADDRESS>\\n"', file=outfile)
    print('"Language-Team: LANGUAGE <LL@li.org>\\n"', file=outfile)
    print('"MIME-Version: 1.0\\n"', file=outfile)
    print('"Content-Type: text/plain; charset=UTF-8\\n"', file=outfile)
    print('"Content-Transfer-Encoding: 8bit\\n"\n', file=outfile)

    sentences_wmacro_by_file = {}
    sentences_wmacro_by_macro = {}
    macro_po_sentences = (sentences_wmacro_by_file, sentences_wmacro_by_macro)
    for posentence in sorted(sentlist.values(), key=lambda x: x.orderid):
        macro = posentence.macro
        if macro is None:
            posentence.write(outfile, args.fuzzy)
            print('', file=outfile)
        else:
            # 1. Identify all strings which require preprocessing, as well as their
            #    reference (file name, line number), and parent macro definition.
            #    These are passed to handle_macro_po_sentences.
            if not macro[1] in sentences_wmacro_by_file:
                sentences_wmacro_by_file[macro[1]] = []
            sentences_wmacro_by_file[macro[1]].append(posentence)
            if not macro in sentences_wmacro_by_macro:
                sentences_wmacro_by_macro[macro] = []
            sentences_wmacro_by_macro[macro].append(posentence)

    if len(sentences_wmacro_by_file) > 0:
        print("Translatable strings with macros found in %d files." % len(sentences_wmacro_by_file))
        handle_macro_po_sentences(sentlist, macro_po_sentences, start_path=startPath, fileref_root=fileref_root, outfile=outfile, fuzzy=args.fuzzy)

    if args.outfile is not None:
        outfile.close()
    if args.debugmode:
        fdebug.close()



def sigint_handler(signal, frame):
    """This function defines what happens when the SIGINT signal is encountered by pressing ctrl-c during runtime. 
    When ctrl-c is pressed, a one-line message is displayed and Python exits with Status 1.
    This overrides Python's default behavior of displaying a traceback when ctrl-c is pressed.
    """
    print ('Aborted by pressing ctrl-c')
    sys.exit(1)



if __name__ == "__main__":
    main()
