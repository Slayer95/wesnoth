#!/usr/bin/env python3


# encoding: utf-8
#
# wmlxgettext -- generate a blank .pot file for official campaigns translations
#                    (build tool for wesnoth core)
#
#
# By Nobun, october 2015
# Thanks to Elvish Hunter for writing code for coloring text under windows
#
#                              PURPOSE
#
# wmlxgettext is a python3 tool that replace the old (but very good)
# perl script with the same name.
# Replacing perl with python3 will ensure more portability.
#
# wmlxgettext is a tool that is directly used during wesnoth build process
# to generate the pot files for the core campaigns.
#
#                              USAGE
#
# If you want to learn how to use wmlxgettext, read the online End-User
# documentation at:
# http://wmlxgettext-unoff.readthedocs.org/en/latest/enduser/index.html
#
#                   SOURCE CODE DOCUMENTATION
#
# While the source code contains some comments that explain what it does at
# that point, the source code is mainly explained on source documentation at:
# http://wmlxgettext-unoff.readthedocs.org/en/latest/srcdoc/index.html

import argparse
from copy import copy
from datetime import datetime
import json
import os
from pprint import PrettyPrinter
import signal
import sys
import warnings
import pywmlx
#from wesnoth.wmlparser3 import Parser
from wesnoth.wmltools3 import CrossRef
from wesnoth.wmlmacro import Macro, CrossRefHelper, ReferenceHelper, evaluate_multi_substitution_for_ast, parse_sentence_for_ast_and_identifiers

printer = PrettyPrinter(indent=4,depth=3)



def commandline(args):
    parser = argparse.ArgumentParser(
        description='Generate .po from WML/lua file list.',
        usage='''wmlxgettext --domain=DOMAIN -o OUTPUT_FILE
                   [--directory=START_PATH]
                   [--recursive] [--initialdomain=INITIAL_DOMAIN]
                   [--package-version=PACKAGE_VERSION]
                   [--no-sort-by-file] [--no-text-colors] [--fuzzy] [--warnall]
                   FILE1 FILE2 ... FILEN'''
    )
    parser.add_argument(
        '--version',
        action='version',
        version='wmlxgettext 2019.09.03.py3'
    )
    parser.add_argument(
        '-o',
        required=True,
        default=None,
        dest='outfile',
        help= ('Destination file. In some special situations you might want '
               'to write the output to STDOUT instead of writing '
               'an actual file (using "-o -"). On a standard usage, however, '
               'you should avoid to write the output to STDOUT (or you can '
               'face some issues related to text encoding). '
               '[**REQUIRED ARGUMENT**]')
    )
    parser.add_argument(
        '--domain',
        default='wmlxgettext',
        required=True,
        dest='domain',
        help= ('The textdomain (on WML/lua file) wich contains the '
               'strings that will be actually translated. '
               '[**REQUIRED ARGUMENT**]')
    )
    parser.add_argument(
        '--directory',
        default='.',
        dest='start_path',
        help=('Complete path of your "start directory". '
              '(Default: current directory). The (relative) path to '
              'every WML/lua file should start from this directory.')
    )
    parser.add_argument(
        '--initialdomain',
        default='wesnoth',
        dest='initdom',
        help=('Initial domain value on WML/lua file when no textdomain '
              'set in that WML/lua file.\nBy default it is equal to '
              '"wesnoth" and usually you don\'t need to change this value.')
    )
    parser.add_argument(
        '--package-version',
        default='PACKAGE VERSION',
        dest='package_version',
        help=('Version number of your wesnoth add-on. You don\'t actually '
              'require to set this option since you can directly edit the '
              'po file produced by wmlxgettext.')
    )
    parser.add_argument(
        '--no-sort-by-file',
        action='store_false',
        default=True,
        dest='sort_by_file',
        help=("By default the list of input files is sorted so that they "
              "are processed in a deterministic order. Use this flag to "
              "process the files in the order that they're named on the "
              "command line.")
    )
    parser.add_argument(
        '--no-text-colors',
        action='store_false',
        default=True,
        dest='text_col',
        help=("By default warnings are displayed with colored text. You can "
              "disable this feature using this flag.")
    )
    parser.add_argument(
        '--warnall',
        action='store_true',
        default=False,
        dest='warnall',
        help="Show all warnings. By default some warnings are hidden."
    )
    parser.add_argument(
        '--fuzzy',
        action='store_true',
        default=False,
        dest='fuzzy',
        help=("If you specify this flag, all sentences contained on the POT "
              "file created by wmlxgettext will be set as fuzzy.\n"
              "By default sentences are NOT set as fuzzy.")
    )
    parser.add_argument(
        '--recursive',
        action='store_true',
        default=False,
        help=("If this option is used, wmlxgettext will scan recursively the "
              "directory set on the '--directory' parameter and checks "
              "itself every WML/lua file. "
              "If this option is used, EXPLICIT LIST of files will be "
              "ignored.")
    )
    parser.add_argument(
        'filelist',
        help='List of WML/lua files of your UMC (source files).',
        nargs='*'
    )

    '''
    Developer Options - not suitable for standard usage:
    --DMode is a reserved flag used to verify how wmlxgettext is internally
            working. When this flag is used (set to ON), an extra
            file (debug.txt) will be created. debug.txt will contain
            useful informations to check if wmlxgettext is working as expected
            (but make sense only for wmlxgettext developers/contributors)
    '''
    parser.add_argument(
        '--DMode',
        action='store_true',
        dest='debugmode',
        default=False,
        help=argparse.SUPPRESS
    )

    return parser.parse_args(args)



def extractor(files, startPath, offset = 0):
    for fileno, fx in enumerate(files):
        if fileno < offset:
            continue

        fname = os.path.join(startPath, os.path.normpath(fx))
        is_file = os.path.isfile(fname)
        if is_file:
            infile = None
            try:
                infile = open(fname, 'r', encoding="utf-8")
            except OSError as e:
                errmsg = 'cannot read file: ' + e.args[1]
                pywmlx.wmlerr(e.filename, errmsg, OSError)
            if fname.lower().endswith('.cfg'):
                pywmlx.statemachine.run(filebuf=infile, fileref=fx,
                            fileno=fileno, startstate='wml_idle', waitwml=True)
            if fname.lower().endswith('.lua'):
                pywmlx.statemachine.run(filebuf=infile, fileref=fx,
                            fileno=fileno, startstate='lua_idle', waitwml=False)
            infile.close()



def handle_macro_po_sentences(sentlist, po_sentences, root_path, outfile, fuzzy):
    ctx_macros = {}
    asts_by_sentence = {}
    identifiers_by_sentence = {}
    (sentences_by_file, sentences_by_macro) = po_sentences
    for fileref, sentences in sentences_by_file.items():
        print("== Pending at %s ==" % (fileref))
        for posentence in sentences:
            lone_identifiers, complex_identifiers = {}, {}
            ast = parse_sentence_for_ast_and_identifiers(posentence.sentence, lone_identifiers, complex_identifiers)
            macro = Macro(*posentence.macro)

            ctx_macros[macro] = True
            asts_by_sentence[posentence.sentence] = ast
            identifiers_by_sentence[posentence.sentence] = (lone_identifiers, complex_identifiers)

            print("\n".join(map(lambda f : "#: " + f, posentence.finfos)))
            print("#. [#define %s]" % (macro))
            print("msgid \"%s\"" % (posentence.sentence))
            print("msgstr \"\"")
            print("")

    args_by_macro_by_file = {} # TODO(perf): Recover for step 4
    xrefs_by_file = {} # TODO(perf): Recover for step 4

    def resolve_strings_at(filelist, single_file):
        xrefs = CrossRef(filelist=filelist)
        po_sentences_this_file = None
        if single_file is not None:
            xrefs_by_file[filelist[0]] = xrefs_by_file
            po_sentences_this_file = sentences_by_file[single_file]

        args_by_macro = {}
        for macro in ctx_macros:
            if single_file and macro.fileref != single_file:
                # Ignore in single-file analysis
                continue

            printer.pprint("Analysis of %s..." % macro)
            xref = macro.to_abs(root_path).get_ref(xrefs)
            is_local = xref.undef is not None
            calls_macro = False

            # Issue #7522: Lack of eager evaluation causes many macros to be exported needlessly.
            # To convince wmlxgettext that exported macros will not be passed novel parameters
            # from different files, add the following comment to every file containing macro'd
            # translatable strings:
            # wmlscope: set wmlxgettext_local_macros=1
            if not is_local and single_file is not None:
                wmlscope_props = list(xrefs.properties.values())
                if len(wmlscope_props) > 0 and "wmlxgettext_local_macros" in wmlscope_props[0] \
                    and wmlscope_props[0]["wmlxgettext_local_macros"] == "1":
                    is_local = True

            if is_local:
                printer.pprint("Macro %s is local" % macro)
            elif single_file is not None:
                # 4.1 Note whether there's an #undef in the same file (i.e whether 
                #     the macro is local or global).
                raise Exception("Macro %s is exported" % macro)

            if single_file:
                contained_sentences = [s for s in po_sentences_this_file if s.macro == macro]
            else:
                contained_sentences = sentences_by_macro[macro]
            all_fps = [identifiers_by_sentence[s.sentence][0] for s in contained_sentences]
            maybe_parameters = {k:v for fps in all_fps for k,v in fps.items()}
            printer.pprint("May be parameters: %s" % ", ".join(maybe_parameters.keys()))
            for identifier in maybe_parameters:
                if not identifier in xref.args and not identifier in xref.optional_args:
                    calls_macro = True
                    break

            if calls_macro:
                printer.pprint("Some contained po sentence evaluates constant macro %s" % identifier)

            complex_id_dicts = [identifiers_by_sentence[s.sentence][1] for s in contained_sentences]
            complex_ids = [k for dict in complex_id_dicts for id in dict.keys()]
            if len(complex_ids) > 0:
                # 4.2. Note whether the macro contains quote marks or WML (error out if so.)
                # 4.3. Note whether the macro contains conditional directives and which.
                # TODO
                printer.pprint("Macros called by %s: %s" % (macro, json.dumps(complex_ids)))

            args_variants = ReferenceHelper.get_macro_called_args(xref, xrefs, maybe_parameters)
            #printer.pprint("Args variants")
            #printer.pprint(" - Raw")
            #printer.pprint(args_variants)
            ReferenceHelper.resolve_called_args_substitutions(args_variants, xrefs)
            args_by_macro[macro] = args_variants
            #printer.pprint(" - Resolved")
            #printer.pprint(args_variants)

        args_by_macro_by_file[fileref] = args_by_macro

    try:
        for fileref in sentences_by_file:
            printer.pprint("CrossRef(filelist=[%s])" % (fileref))
            resolve_strings_at([os.path.join(root_path, fileref)], fileref)
    except Exception as ex:
        printer.pprint(ex)
        printer.pprint("Fallback to full-tree analysis")
        resolve_strings_at([os.path.join(root_path, fileref) for fileref in sentences_by_file], None)

    new_sentences = {}
    for fileref in sentences_by_file:
        args_by_macro = args_by_macro_by_file[fileref]
        for macro in args_by_macro:
            args_variants = args_by_macro[macro]
            for po_sentence in sentences_by_macro[macro]:
                sentence_ast = asts_by_sentence[po_sentence.sentence]
                sentence_alternatives = evaluate_multi_substitution_for_ast(sentence_ast, args_variants)
                for alternative in sentence_alternatives:
                    assert(type(alternative) == tuple)
                    assert(type(alternative[0]) == str)
                    assert(isinstance(alternative[1], Macro))
                    po_sentence_variant = copy(po_sentence)
                    po_sentence_variant.sentence = alternative[0]
                    if po_sentence_variant.sentence in sentlist:
                        printer.pprint("Ignored ref to raw sentence %s" % po_sentence_variant.sentence)
                        #Output has already been written. TODO: FIXME?
                        #sentlist[po_sentence_variant.sentence].update_with_commented_string(po_sentence_variant)
                    elif po_sentence_variant.sentence in new_sentences:
                        printer.pprint("New ref in processed sentence %s" % po_sentence_variant.sentence)
                        new_sentences[po_sentence_variant.sentence].update_with_commented_string(po_sentence_variant)
                    else:
                        printer.pprint("New sentence %s" % po_sentence_variant.sentence)
                        new_sentences[po_sentence_variant.sentence] = po_sentence_variant

    for posentence in new_sentences.values():
        posentence.write(outfile, fuzzy)
        print('', file=outfile)


def main():
    signal.signal(signal.SIGINT, sigint_handler)
    args = commandline(sys.argv[1:])
    pywmlx.ansi_setEnabled(args.text_col)
    pywmlx.wincol_setEnabled(args.text_col)
    pywmlx.set_warnall(args.warnall)
    startPath = os.path.realpath(os.path.normpath(args.start_path))
    sentlist = dict()
    fdebug = None
    if args.outfile == '-':
        args.outfile = None
    if args.debugmode:
        fdebug = open('debug.txt', 'w', encoding='utf-8')
    pywmlx.statemachine.setup(sentlist, args.initdom, args.domain,
                              args.warnall, fdebug)
    if args.recursive is False and args.filelist is None:
        pywmlx.wmlerr("bad command line", "FILELIST must not be empty. "
               "Please, run wmlxgettext again and, this time, add some file "
               "in FILELIST or use the --recursive option.")
    elif args.recursive is False and len(args.filelist) <= 0:
        pywmlx.wmlerr("bad command line", "FILELIST must not be empty. "
               "Please, run wmlxgettext again and, this time, add some file "
               "in FILELIST or use the --recursive option.")
    elif args.recursive is False:
        filelist = args.filelist
    # the following elif case implicitly expects that args.recursive is True
    elif args.filelist is not None:
        if len(args.filelist) > 0:
            pywmlx.wmlwarn("command line warning", "Option --recursive was "
                "used, but FILELIST is not empty. All extra file listed in "
                "FILELIST will be ignored.")
        # If we use the --recursive option we recursively scan the add-on
        # directory.
        #    But we want that the file reference informations placed
        # in the .po file will remember the (relative) root name of the
        # addon.
        #    This is why the autof.autoscan function returns a tuple of
        # values:
        #   the first one is the parent directory of the original startPath
        #   the second one is the filelist (with the "fixed" file references)
        # This way, we can override startPath with its parent directory
        # containing the main directory of the wesnoth add-on, without
        # introducing bugs.
        startPath, filelist = pywmlx.autof.autoscan(startPath)
    # this last case is equal to:
    # if args.recursive is True and args.filelist is None:
    else:
        startPath, filelist = pywmlx.autof.autoscan(startPath)
    if args.sort_by_file:
        filelist.sort()
 
    extractor(filelist, startPath)

    outfile = None
    if args.outfile is None:
        outfile = sys.stdout
    else:
        outfile_name = os.path.realpath(os.path.normpath(args.outfile))
        try:
            outfile = open(outfile_name, 'w', encoding="utf-8")
        except OSError as e:
            errmsg = 'cannot write file: ' + e.args[1]
            pywmlx.wmlerr(e.filename, errmsg, OSError)
    pkgversion = args.package_version + '\\n"'
    print('msgid ""\nmsgstr ""', file=outfile)
    print('"Project-Id-Version:', pkgversion, file=outfile)
    print('"Report-Msgid-Bugs-To: https://bugs.wesnoth.org/\\n"', file=outfile)
    now = datetime.utcnow()
    cdate = '{:04d}-{:02d}-{:02d} {:02d}:{:02d} UTC\\n"'.format(now.year,
                                                                now.month,
                                                                now.day,
                                                                now.hour,
                                                                now.minute)

    print('"POT-Creation-Date:', cdate, file=outfile)
    print('"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\\n"', file=outfile)
    print('"Last-Translator: FULL NAME <EMAIL@ADDRESS>\\n"', file=outfile)
    print('"Language-Team: LANGUAGE <LL@li.org>\\n"', file=outfile)
    print('"MIME-Version: 1.0\\n"', file=outfile)
    print('"Content-Type: text/plain; charset=UTF-8\\n"', file=outfile)
    print('"Content-Transfer-Encoding: 8bit\\n"\n', file=outfile)

    sentences_wmacro_by_file = {}
    sentences_wmacro_by_macro = {}
    macro_po_sentences = (sentences_wmacro_by_file, sentences_wmacro_by_macro)
    for posentence in sorted(sentlist.values(), key=lambda x: x.orderid):
        macro = posentence.macro
        if macro is None:
            posentence.write(outfile, args.fuzzy)
            print('', file=outfile)
        else:
            if not macro[1] in sentences_wmacro_by_file:
                sentences_wmacro_by_file[macro[1]] = []
            sentences_wmacro_by_file[macro[1]].append(posentence)
            if not macro in sentences_wmacro_by_macro:
                sentences_wmacro_by_macro[macro] = []
            sentences_wmacro_by_macro[macro].append(posentence)

    if len(sentences_wmacro_by_file) > 0:
        handle_macro_po_sentences(sentlist, macro_po_sentences, startPath, outfile, args.fuzzy)

    if args.outfile is not None:
        outfile.close()
    if args.debugmode:
        fdebug.close()



def sigint_handler(signal, frame):
    """This function defines what happens when the SIGINT signal is encountered by pressing ctrl-c during runtime. 
    When ctrl-c is pressed, a one-line message is displayed and Python exits with Status 1.
    This overrides Python's default behavior of displaying a traceback when ctrl-c is pressed.
    """
    print ('Aborted by pressing ctrl-c')
    sys.exit(1)



if __name__ == "__main__":
    main()
